/*******************************************************************************
  Copyright(c) 2015 Radek Kaczorek  <rkaczorek AT gmail DOT com>

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library General Public
 License version 2 as published by the Free Software Foundation.
 .
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Library General Public License for more details.
 .
 You should have received a copy of the GNU Library General Public License
 along with this library; see the file COPYING.LIB.  If not, write to
 the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 Boston, MA 02110-1301, USA.
*******************************************************************************/

#include <stdio.h>
#include <iostream>
#include <string>
#include <memory>
#include <RTIMULib.h>

#include "rpi_altimu.h"


#define POLLMS 500

// We declare an auto pointer to IndiRpialtimu
std::auto_ptr<IndiRpialtimu> indiRpialtimu(0);

void ISPoll(void *p);
void ISInit()
{
   static int isInit =0;

   if (isInit == 1)
       return;

    isInit = 1;
    if(indiRpialtimu.get() == 0) indiRpialtimu.reset(new IndiRpialtimu());
    //IEAddTimer(POLLMS, ISPoll, NULL);

}
void ISGetProperties(const char *dev)
{
        ISInit();
        indiRpialtimu->ISGetProperties(dev);
}
void ISNewSwitch(const char *dev, const char *name, ISState *states, char *names[], int num)
{
        ISInit();
        indiRpialtimu->ISNewSwitch(dev, name, states, names, num);
}
void ISNewText(	const char *dev, const char *name, char *texts[], char *names[], int num)
{
        ISInit();
        indiRpialtimu->ISNewText(dev, name, texts, names, num);
}
void ISNewNumber(const char *dev, const char *name, double values[], char *names[], int num)
{
        ISInit();
        indiRpialtimu->ISNewNumber(dev, name, values, names, num);
}
void ISNewBLOB (const char *dev, const char *name, int sizes[], int blobsizes[], char *blobs[], char *formats[], char *names[], int num)
{
  INDI_UNUSED(dev);
  INDI_UNUSED(name);
  INDI_UNUSED(sizes);
  INDI_UNUSED(blobsizes);
  INDI_UNUSED(blobs);
  INDI_UNUSED(formats);
  INDI_UNUSED(names);
  INDI_UNUSED(num);
}
void ISSnoopDevice (XMLEle *root)
{
    ISInit();
    indiRpialtimu->ISSnoopDevice(root);
}
IndiRpialtimu::IndiRpialtimu()
{
}
IndiRpialtimu::~IndiRpialtimu()
{
}
bool IndiRpialtimu::Connect()
{
	//  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
	RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

	imu = RTIMU::createIMU(settings);
	pressure = RTPressure::createPressure(settings);

	if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
		IDMessage(getDeviceName(), "Astroberry AltIMU fatal error - no IMU found.");
		return false;
	}

	//  This is an opportunity to manually override any settings before the call IMUInit

	//  set up IMU
	if (!imu->IMUInit())
	{
		IDMessage(getDeviceName(), "Astroberry AltIMU fatal error - problem initiating IMU.");
		return false;
	}

    //  set up pressure sensor
    if (pressure != NULL)
        pressure->pressureInit();

    //  set up for rate timer
    rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

	// first timer run @1/100 recommended sampling rate
    SetTimer ( imu->IMUGetPollInterval() * 100 );
	
    IDMessage(getDeviceName(), "Astroberry AltIMU connected successfully.");
        	
    return true;
}
bool IndiRpialtimu::Disconnect()
{
    IDMessage(getDeviceName(), "Astroberry AltIMU disconnected successfully.");
    return true;
}
void IndiRpialtimu::TimerHit()
{
	if(isConnected())
	{
		//IDMessage(getDeviceName(), "Timer Hit");
		IndiRpialtimu::GetSensorData();
		
		// loop run @1/100 recommended sampling rate
		SetTimer( imu->IMUGetPollInterval() * 100 );
    }
}
const char * IndiRpialtimu::getDefaultName()
{
        return (char *)"Astroberry AltIMU";
}
bool IndiRpialtimu::initProperties()
{
    // We init parent properties first
    INDI::DefaultDevice::initProperties();

    IUFillNumber(&PositionN[0],"ROLL","Roll (arc deg)","%0.1f",-180,180,0,0.0);
    IUFillNumber(&PositionN[1],"PITCH","Pitch (arc deg)","%0.1f",-180,180,0,0.0 );
    IUFillNumber(&PositionN[2],"YAW","Yaw (arc deg)","%0.1f",-180,180,0,0.0 );
    IUFillNumberVector(&PositionNP,PositionN,3,getDeviceName(),"ORIENTATION","Orientation",MAIN_CONTROL_TAB,IP_RO,60,IPS_OK);

    IUFillNumber(&PressureN[0],"PRESS_VALUE","Pressure (hPa)","%0.1f",0,2000,0,0.0);
    IUFillNumberVector(&PressureNP,PressureN,1,getDeviceName(),"PRESS","Pressure",MAIN_CONTROL_TAB,IP_RO,60,IPS_OK);

    IUFillNumber(&AltitudeN[0],"ALT_VALUE","Height over see level (m)","%0.1f",0,20000,0,0.0);
    IUFillNumberVector(&AltitudeNP,AltitudeN,1,getDeviceName(),"ALT","Altitude",MAIN_CONTROL_TAB,IP_RO,60,IPS_OK);

    IUFillNumber(&TemperatureN[0],"TEMP_VALUE","Temperature (C)","%0.1f",0,100,0,0.0);
    IUFillNumberVector(&TemperatureNP,TemperatureN,1,getDeviceName(),"TEMP","Temperature",MAIN_CONTROL_TAB,IP_RO,60,IPS_OK);

    IUFillNumber(&AdjustmentN[0],"ROLL","Roll (arc deg)","%0.1f",-180,180,0,0.0);
    IUFillNumber(&AdjustmentN[1],"PITCH","Pitch (arc deg)","%0.1f",-180,180,0,0.0 );
    IUFillNumber(&AdjustmentN[2],"YAW","Yaw (arc deg)","%0.1f",-180,180,0,0.0 );
    IUFillNumberVector(&AdjustmentNP,AdjustmentN,3,getDeviceName(),"ADJUSTMENT","Adjustment",OPTIONS_TAB,IP_RW,60,IPS_OK);
    
    return true;
}
bool IndiRpialtimu::updateProperties()
{
    // Call parent update properties first
    INDI::DefaultDevice::updateProperties();

    if (isConnected())
    {
        defineNumber(&PositionNP);
		defineNumber(&PressureNP);
		defineNumber(&AltitudeNP);
		defineNumber(&TemperatureNP);
		defineNumber(&AdjustmentNP);
		
		loadConfig();	
    }
    else
    {
		// We're disconnected
		deleteProperty(PositionNP.name);
        deleteProperty(PressureNP.name);
        deleteProperty(AltitudeNP.name);
        deleteProperty(TemperatureNP.name);
        deleteProperty(AdjustmentNP.name);
    }
    return true;
}
void IndiRpialtimu::ISGetProperties(const char *dev)
{
    INDI::DefaultDevice::ISGetProperties(dev);

    /* Add debug controls so we may debug driver if necessary */
    //addDebugControl();
}
bool IndiRpialtimu::ISNewNumber (const char *dev, const char *name, double values[], char *names[], int n)
{
	// first we check if it's for our device
    if (!strcmp(dev, getDeviceName()))
    {
		// handle sync with scope
		if(!strcmp(name, AdjustmentNP.name))
		{		
			IUUpdateNumber(&AdjustmentNP, values, names, n);
			IDSetNumber(&AdjustmentNP, "Astroberry AltIMU correction entered - roll: %0.3f, pitch: %0.3f, yaw: %0.3f", AdjustmentN[0].value, AdjustmentN[1].value, AdjustmentN[2].value);
		}
	}
	
	return INDI::DefaultDevice::ISNewNumber(dev,name,values,names,n);
}
bool IndiRpialtimu::ISNewSwitch (const char *dev, const char *name, ISState *states, char *names[], int n)
{
	return INDI::DefaultDevice::ISNewSwitch (dev, name, states, names, n);
}
bool IndiRpialtimu::ISNewText (const char *dev, const char *name, char *texts[], char *names[], int n)
{	
	return INDI::DefaultDevice::ISNewText (dev, name, texts, names, n);
}
bool IndiRpialtimu::ISNewBLOB (const char *dev, const char *name, int sizes[], int blobsizes[], char *blobs[], char *formats[], char *names[], int n)
{
	return INDI::DefaultDevice::ISNewBLOB (dev, name, sizes, blobsizes, blobs, formats, names, n);
}
bool IndiRpialtimu::ISSnoopDevice(XMLEle *root)
{
    //controller->ISSnoopDevice(root);

    return INDI::DefaultDevice::ISSnoopDevice(root);
}
bool IndiRpialtimu::saveConfigItems(FILE *fp)
{
	IUSaveConfigNumber(fp, &AdjustmentNP);

    //controller->saveConfigItems(fp);

    return true;
}

bool IndiRpialtimu::GetSensorData()
{
	while (imu->IMURead()) {
		RTIMU_DATA imuData = imu->getIMUData();

		//  add the pressure data to the structure
		if (pressure != NULL)
			pressure->pressureRead(imuData);

			// IDMessage(getDeviceName(), RTMath::displayDegrees("IMUPose", imuData.fusionPose));
			// "IMUPose: roll:-4,047922, pitch:0,772075, yaw:-108,961994"

			std::string pose = RTMath::displayDegrees("IMUPose", imuData.fusionPose);

			std::size_t pos1 = pose.find("roll:");
			std::string roll = pose.substr (pos1 + 5, pose.find(", pitch:") - 1);

			std::size_t pos2 = pose.find("pitch:");
			std::string pitch = pose.substr (pos2 + 6, pose.find(", yaw:") - 1);

			std::size_t pos3 = pose.find("yaw:");
			std::string yaw = pose.substr (pos3 + 4);

			PositionN[0].value = std::stod (roll) + AdjustmentN[0].value;
			PositionN[1].value = std::stod (pitch) + AdjustmentN[1].value;
			PositionN[2].value = std::stod (yaw) + AdjustmentN[2].value;

			if (pressure != NULL) {
				// IDMessage(getDeviceName(), "Pressure: %4.1f, height above sea level: %4.1f, temperature: %4.1f\n", imuData.pressure, RTMath::convertPressureToHeight(imuData.pressure), imuData.temperature);
					PressureN[0].value = imuData.pressure;
					AltitudeN[0].value = RTMath::convertPressureToHeight(imuData.pressure);
					TemperatureN[0].value = imuData.temperature;
			}
	}
	// set values for INDI
	IDSetNumber(&PositionNP, NULL);
	IDSetNumber(&PressureNP, NULL);
	IDSetNumber(&AltitudeNP, NULL);
	IDSetNumber(&TemperatureNP, NULL);

	return true;
}
